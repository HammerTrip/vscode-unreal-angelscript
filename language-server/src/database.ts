export enum DBAllowSymbol
{
    None = 0,
    All = ~0,

    Properties = 1 << 0,
    Functions = 1 << 1,
    Mixins = 1 << 2,
    Types = 1 << 3,

    PropertiesAndFunctions = Properties | Functions,
    FunctionsAndMixins = Functions | Mixins,
};

export function AllowsFunctions(allowSymbol : DBAllowSymbol)
{
    return (allowSymbol & DBAllowSymbol.Functions) != 0;
}

export function AllowsProperties(allowSymbol : DBAllowSymbol)
{
    return (allowSymbol & DBAllowSymbol.Properties) != 0;
}

export enum DBTypeClassification
{
    Unknown,
    Other,
    Component,
    Actor,
    Struct,
    Event,
    Delegate,
    Primitive
};

export interface DBSymbol
{
    name : string;
    containingType : DBType;
    namespace : DBNamespace;
    keywords : Array<string>;
    declaredModule : string | null;
    auxiliarySymbols : Array<DBAuxiliarySymbol> | null;
};

export interface DBAuxiliarySymbol
{
    symbol_name : string;
    container_type : string;
};

export class DBProperty implements DBSymbol
{
    name : string;
    typename : string;
    documentation : string;
    isProtected : boolean = false;
    isPrivate : boolean = false;
    isNoEdit : boolean = false;
    isEditOnly : boolean = false;
    isAutoGenerated : boolean = false;
    isLiteralAsset : boolean = false;

    accessSpecifier : DBAccessSpecifier = null;
    declaredModule : string | null;
    moduleOffset : number;
    moduleOffsetEnd : number = -1;

    containingType : DBType = null;
    namespace : DBNamespace = null;
    keywords : Array<string> = null;

    isUProperty : boolean = false;
    macroSpecifiers : Map<string, string> = null;
    macroMeta : Map<string, string> = null;
    auxiliarySymbols : Array<DBAuxiliarySymbol> | null = null;

    fromJSON(name : string, input : any)
    {
        this.name = name;
        this.typename = input[0];
        this.isProtected = false;
        this.isPrivate = false;
        this.isNoEdit = false;
        this.isEditOnly = false;

        if (input.length >= 3)
        {
            if (input[1] == 'NoEdit')
                this.isNoEdit = true;
            else if (input[1] == 'EditOnly')
                this.isEditOnly = true;

            this.documentation = FormatDocumentationComment(input[2]);
        }
        else if (input.length >= 2)
        {
            if (input[1] == 'NoEdit')
                this.isNoEdit = true;
            else if (input[1] == 'EditOnly')
                this.isEditOnly = true;
            else if (!input[1].startsWith("+"))
                this.documentation = FormatDocumentationComment(input[1]);
        }
    }

    format(prefix : string = null) : string
    {
        let str : string = "";
        if (this.isProtected)
            str += "protected ";
        if (this.isPrivate)
            str += "private ";
        str += this.typename;
        str += " ";
        if (prefix)
            str += prefix;
        str += this.name;
        return str;
    }

    createTemplateInstance(templateTypes : Array<string>, actualTypes : Array<string>) : DBProperty
    {
        let inst = new DBProperty();
        inst.name = this.name;
        inst.typename = ReplaceTemplateType(this.typename, templateTypes, actualTypes);
        return inst;
    }
};

export class DBArg
{
    name : string | null;
    typename : string;
    defaultvalue : string | null;

    init(typename : string, name : string, defaultvalue : string = "") : DBArg
    {
        this.name = name;
        this.typename = typename;
        if (defaultvalue)
            this.defaultvalue = defaultvalue;
        return this;
    }

    fromJSON(input : any)
    {
        this.name = 'name' in input ? input['name'] : null;
        this.typename = input['type'];
        this.defaultvalue = 'default' in input ? input['default'] : null;
    }

    format() : string
    {
        let decl = this.typename;
        if (this.name != null)
            decl += " " + this.name;
        if (this.defaultvalue != null)
            decl += " = " + this.defaultvalue;
        return decl;
    }

    createTemplateInstance(templateTypes : Array<string>, actualTypes : Array<string>) : DBArg
    {
        let inst = new DBArg();
        inst.name = this.name;
        inst.defaultvalue = this.defaultvalue;
        inst.typename = ReplaceTemplateType(this.typename, templateTypes, actualTypes);
        return inst;
    }
};

export enum DBMethodAnnotation
{
    None,
    IsHexColor,
    IsLinearColor,
};

export class DBMethod implements DBSymbol
{
    name : string;
    returnType : string;
    args : Array<DBArg>;
    argumentStr : string;
    documentation : string;
    isProtected : boolean = false;
    isPrivate : boolean = false;
    isConstructor : boolean = false;
    isBlueprintEvent : boolean = false;
    isBlueprintOverride : boolean = false;
    isConst : boolean = false;
    isFinal : boolean = false;
    isProperty : boolean = false;
    isOverride : boolean = false;
    isDefaultsOnly : boolean = false;
    isLocal : boolean = false;
    id : number = NextMethodId++;
    containingType : DBType = null;
    namespace : DBNamespace = null;
    keywords : Array<string> = null;
    isAutoGenerated : boolean = false;
    isMixin : boolean = false;
    accessSpecifier : DBAccessSpecifier = null;
    auxiliarySymbols : Array<DBAuxiliarySymbol> | null = null;

    isUFunction : boolean = false;
    macroSpecifiers : Map<string, string> = null;
    macroMeta : Map<string, string> = null;

    hasSuperCall : boolean = false;
    isEmpty : boolean = false;

    isDelegateBindFunction : boolean = false;
    delegateBindType : string = null;
    delegateObjectParam : number = -1;
    delegateFunctionParam : number = -1;

    methodAnnotation : DBMethodAnnotation = DBMethodAnnotation.None;

    declaredModule : string;
    moduleOffset : number;
    moduleOffsetEnd : number = -1;
    moduleScopeStart : number = -1;
    moduleScopeEnd : number = -1;

    createTemplateInstance(templateTypes : Array<string>, actualTypes : Array<string>) : DBMethod
    {
        let inst = new DBMethod();
        inst.name = this.name;
        inst.returnType = ReplaceTemplateType(this.returnType, templateTypes, actualTypes);
        inst.argumentStr = this.argumentStr;
        inst.documentation = this.documentation;
        inst.isProtected = this.isProtected;
        inst.isPrivate = this.isPrivate;
        inst.isConstructor = this.isConstructor;
        inst.isBlueprintEvent = this.isBlueprintEvent;
        inst.isBlueprintOverride = this.isBlueprintOverride;
        inst.isConst = this.isConst;
        inst.isProperty = this.isProperty;
        inst.isDefaultsOnly = this.isDefaultsOnly;

        inst.args = [];
        for(let argval of this.args)
            inst.args.push(argval.createTemplateInstance(templateTypes, actualTypes));
        return inst;
    }

    fromJSON(input : any)
    {
        this.name = input.name;

        if ('return' in input)
            this.returnType = input['return'];
        else
            this.returnType = 'void';

        this.args = new Array<DBArg>();
        if ('args' in input)
        {
            for (let argDesc of input['args'])
            {
                let arg = new DBArg;
                arg.fromJSON(argDesc);

                this.args.push(arg);
            }
        }

        if ('doc' in input)
            this.documentation = FormatDocumentationComment(input['doc']);
        else
            this.documentation = null;

        if ('isConstructor' in input)
            this.isConstructor = input['isConstructor'];
        else
            this.isConstructor = false;

        if ('const' in input)
            this.isConst = input['const'];
        else
            this.isConst = false;

        if ('event' in input)
            this.isBlueprintEvent = input['event'];
        else
            this.isBlueprintEvent = false;

        if ('isProperty' in input)
            this.isProperty = input['isProperty'];
        else
            this.isProperty = true;

        if ('defaultsonly' in input)
            this.isDefaultsOnly = input['defaultsonly'];

        if ('keywords' in input)
            this.keywords = input['keywords'];

        if ('meta' in input)
        {
            if (!this.macroMeta)
                this.macroMeta = new Map<string, string>();
            for (let metaSpec in input['meta'])
                this.macroMeta.set(metaSpec.toLowerCase(), input['meta'][metaSpec]);
            this.cacheDelegateMeta();
        }
    }

    cacheDelegateMeta()
    {
        if (!this.macroMeta)
            return;

        if (this.macroMeta.has("delegatefunctionparam")
            && this.macroMeta.has("delegateobjectparam")
            && this.macroMeta.has("delegatebindtype"))
        {
            this.isDelegateBindFunction = true;
            this.delegateBindType = this.macroMeta.get("delegatebindtype");

            let functionParam = this.macroMeta.get("delegatefunctionparam");
            let objectParam = this.macroMeta.get("delegateobjectparam");

            for (let i = 0, count = this.args.length; i < count; ++i)
            {
                if (this.args[i].name == objectParam)
                    this.delegateObjectParam = i;
                else if (this.args[i].name == functionParam)
                    this.delegateFunctionParam = i;
            }

        }
    }

    format(prefix : string = null, skipFirstArg = false, skipReturn = false, replaceName : string = null) : string
    {
        let decl : string = "";
        if (!skipReturn)
            decl += this.returnType + " ";
        if(prefix != null)
            decl += prefix;
        if (replaceName)
            decl += replaceName + "(";
        else
            decl += this.name + "(";
        let firstArg = true;
        if (this.argumentStr)
        {
            let argStr = this.argumentStr;
            if (skipFirstArg)
            {
                let cPos = argStr.search(",");
                if(cPos != -1)
                    argStr = argStr.substr(cPos+1).trim();
                else
                    argStr = "";
            }
            decl += argStr;
        }
        else if(this.args)
        {
            for(let i = 0; i < this.args.length; ++i)
            {
                if (skipFirstArg && i == 0)
                    continue;

                if (i > 0 || (skipFirstArg && i > 1))
                    decl += ", ";
                decl += this.args[i].format();
            }
        }
        decl += ")";
        if (this.isConst)
            decl += " const";
        if (this.isProperty && this.declaredModule)
            decl += " property";
        return decl;
    }

    // Get documentation either from this function or from the
    // first parent function we're overriding
    findAvailableDocumentation(includeParent = true, includeType = true) : string
    {
        if (this.documentation)
            return this.documentation;
        // Use the parent function's documentation
        if (this.containingType && includeParent)
        {
            for (let checktype of this.containingType.getInheritanceTypes())
            {
                let parentFunc = checktype.findFirstSymbol(this.name, DBAllowSymbol.Functions);
                if (parentFunc && parentFunc instanceof DBMethod && parentFunc.documentation)
                    return parentFunc.documentation;
            }
        }
        // Use the type's documentation for constructors
        if (this.isConstructor && includeType)
        {
            let dbReturn = LookupType(this.namespace, this.returnType);
            if (dbReturn && dbReturn instanceof DBType && dbReturn.documentation)
                return dbReturn.documentation;
        }
        return null;
    }

    hasMetaData(meta : string) : boolean
    {
        if (!this.macroMeta)
            return false;
        return this.macroMeta.has(meta.toLowerCase());
    }

    getRequiredArgumentCount() : number
    {
        if (!this.args)
            return 0;
        for (let i = 0, argCount = this.args.length; i < argCount; ++i)
        {
            if (this.args[i].defaultvalue)
                return i;
        }
        return this.args.length;
    }

    isSignatureEqual(otherFunc : DBMethod) : boolean
    {
        if ((!!this.args) != (!!otherFunc.args))
            return false;

        if (this.args)
        {
            if (this.args.length != otherFunc.args.length)
                return false;
            for (let i = 0, argCount = this.args.length; i < argCount; ++i)
            {
                if (this.args[i].typename != otherFunc.args[i].typename)
                    return false;
            }
        }

        if (this.returnType != otherFunc.returnType)
            return false;

        return true;
    }

    IsAccessibleFromModule(module : string) : boolean
    {
        if (this.isLocal)
        {
            if (this.declaredModule && this.declaredModule != module)
                return false;
        }

        return true;
    }
};

export class DBType implements DBSymbol
{
    typeid : number = -1;
    name : string;
    supertype : string;
    properties : Array<DBProperty>;
    methods : Array<DBMethod>;
    unrealsuper : string;
    documentation : string;
    namespace : DBNamespace;

    isStruct : boolean;
    isEnum : boolean;
    isDelegate : boolean = false;
    isEvent : boolean = false;
    isPrimitive : boolean = false;
    isTemplateInstantiation : boolean = false;

    classification : DBTypeClassification = DBTypeClassification.Unknown;
    acccessSpecifiers : Array<DBAccessSpecifier> = null;

    keywords : Array<string> = null;
    macroSpecifiers : Map<string, string> = null;
    macroMeta : Map<string, string> = null;

    delegateArgs : Array<DBArg> = null;
    delegateReturn : string = null;

    declaredModule : string;
    moduleOffset : number;
    moduleOffsetEnd : number = -1;
    moduleScopeStart : number = -1;
    moduleScopeEnd : number = -1;

    templateSubTypes : Array<string>;

    symbols = new Map<string, DBSymbol | Array<DBSymbol>>();
    symbolsByPrefix = new Map<string, Array<DBSymbol>>();

    containingType : DBType = null;
    auxiliarySymbols : Array<DBAuxiliarySymbol> | null = null;

    createTemplateInstance(actualTypes : Array<string>) : DBType
    {
        if (actualTypes.length != this.templateSubTypes.length)
            return null;

        let inst = new DBType();
        inst.name = this.name;
        inst.supertype = this.supertype;
        inst.isEnum = this.isEnum;
        inst.declaredModule = this.declaredModule;
        inst.moduleOffset = this.moduleOffset;
        inst.moduleOffsetEnd = this.moduleOffsetEnd;
        inst.isTemplateInstantiation = true;
        inst.templateSubTypes = null;

        inst.properties = [];
        for (let prop of this.properties)
        {
            let newProp = prop.createTemplateInstance(this.templateSubTypes, actualTypes);
            inst.properties.push(newProp);
            inst.addSymbol(newProp);
        }

        inst.methods = [];
        for (let mth of this.methods)
        {
            let newMethod = mth.createTemplateInstance(this.templateSubTypes, actualTypes);
            inst.methods.push(newMethod);
            inst.addSymbol(newMethod);
        }

        return inst;
    }

    initEmpty(name : string) : DBType
    {
        this.name = name;
        this.methods = new Array<DBMethod>();
        this.properties = new Array<DBProperty>();
        return this;
    }

    fromJSON(name : string, input : any)
    {
        this.name = name;
        this.properties = new Array<DBProperty>();
        for (let key in input.properties)
        {
            let prop = new DBProperty();
            prop.fromJSON(key, input.properties[key]);
            this.properties.push(prop);
            this.addSymbol(prop);
        }
        this.methods = new Array<DBMethod>();
        for (let key in input.methods)
        {
            let func = new DBMethod();
            func.fromJSON(input.methods[key]);
            this.methods.push(func);
            this.addSymbol(func);
        }

        if ('subtypes' in input)
        {
            this.templateSubTypes = new Array<string>();
            for(let subtype of input['subtypes'])
            {
                this.templateSubTypes.push(subtype);
            }
        }

        if ('supertype' in input)
        {
            this.unrealsuper = input['supertype'];
        }

        if ('inherits' in input)
        {
            this.supertype = input['inherits'];
        }

        if ('doc' in input)
            this.documentation = FormatDocumentationComment(input['doc']);
        else
            this.documentation = null;

        if ('keywords' in input)
            this.keywords = input['keywords'];

        if ('isStruct' in input)
            this.isStruct = input['isStruct'];
        else
            this.isStruct = false;

        if ('isEnum' in input)
            this.isEnum = input['isEnum'];
        else
            this.isEnum = false;

        let delegateSignatureMethod : DBSymbol = null;
        if ('isEvent' in input)
        {
            this.isEvent = input['isEvent'];
            if (this.isEvent)
                delegateSignatureMethod = this.findFirstSymbol("Broadcast");
        }
        else
        {
            delegateSignatureMethod = this.findFirstSymbol("Broadcast");
            this.isEvent = delegateSignatureMethod != null;
        }

        if ('isDelegate' in input)
        {
            this.isDelegate = input['isDelegate'];
            if (this.isDelegate)
                delegateSignatureMethod = this.findFirstSymbol("ExecuteIfBound");
        }
        else
        {
            if (!this.isEvent)
            {
                delegateSignatureMethod = this.findFirstSymbol("ExecuteIfBound");
                this.isDelegate = delegateSignatureMethod != null;
            }
            else
            {
                this.isDelegate = false;
            }
        }

        if (delegateSignatureMethod != null && delegateSignatureMethod instanceof DBMethod)
        {
            // Detect the signature for the delegate from the Broadcast or ExecuteIfBound methods
            this.delegateArgs = delegateSignatureMethod.args;
            this.delegateReturn = delegateSignatureMethod.returnType;

            // Mark the Add/Bind/Unbind functions so diagnostics can see them
            let bindFuncs: DBSymbol[] = [];
            if (this.isEvent)
                bindFuncs = [this.findFirstSymbol("AddUFunction"), this.findFirstSymbol("Unbind")];
            else
                bindFuncs = [this.findFirstSymbol("BindUFunction")];

            bindFuncs.forEach((bindFunc: DBSymbol) => {
                if (bindFunc instanceof DBMethod)
                {
                    bindFunc.isDelegateBindFunction = true;
                    bindFunc.delegateBindType = this.name;
                    bindFunc.delegateObjectParam = 0;
                    bindFunc.delegateFunctionParam = 1;
                }
            });
        }
    }

    getDisplayName() : string
    {
        return this.name;
    }

    isTemplateType() : boolean
    {
        return this.templateSubTypes && this.templateSubTypes.length != 0;
    }

    getSuperType() : DBType
    {
        if (!this.supertype)
            return null;
        return LookupType(this.namespace, this.supertype);
    }

    equalsTypename(typename : string) : boolean
    {
        if (typename == this.name)
            return true;
        let cleaned = CleanTypeName(typename);
        if (cleaned == this.name)
            return true;
        return false;
    }

    isUnrealType() : boolean
    {
        return !this.declaredModule;
    }

    hasExtendTypes() : boolean
    {
        if(this.supertype)
            return true;
        return false;
    }

    combineTypes : Array<DBType> = null;
    combineTypesId : number = -1;
    getCombineTypesList() : Array<DBType>
    {
        if (this.combineTypes)
        {
            if (this.combineTypesId == DirtyTypeCacheId)
                return this.combineTypes;
        }

        this.combineTypes = [ this ];
        this.combineTypesId = DirtyTypeCacheId;
        let checkIndex = 0;
        while (checkIndex < this.combineTypes.length)
        {
            let checkType = this.combineTypes[checkIndex];

            if (checkType.supertype)
            {
                let dbsuper = LookupType(checkType.namespace, checkType.supertype);
                if(dbsuper && !this.combineTypes.includes(dbsuper))
                    this.combineTypes.push(dbsuper);
            }

            checkIndex += 1;
        }

        return this.combineTypes;
    }

    allProperties() : Array<DBProperty>
    {
        if (!this.hasExtendTypes())
            return this.properties;

        let props : Array<DBProperty> = [];
        for(let extend of this.getCombineTypesList())
            props = props.concat(extend.properties);
        return props;
    }

    formatDelegateSignature() : string
    {
        let decl : string = "";
        if (this.delegateReturn)
            decl += this.delegateReturn + " ";
        decl += this.name + "(";
        if(this.delegateArgs)
        {
            for(let i = 0; i < this.delegateArgs.length; ++i)
            {
                if (i > 0)
                    decl += ", ";
                decl += this.delegateArgs[i].format();
            }
        }
        decl += ")";
        return decl;
    }

    getProperty(name : string, recurse : boolean = true) : DBProperty | null
    {
        for (let prop of this.properties)
        {
            if (prop.name == name)
            {
                return prop;
            }
        }

        if (!recurse)
            return null;

        if (!this.hasExtendTypes())
            return null;

        for(let extend of this.getCombineTypesList())
        {
            let prop = extend.getProperty(name, false);
            if(prop)
                return prop;
        }

        return null;
    }

    getMethod(name : string, recurse : boolean = true) : DBMethod | null
    {
        for (let func of this.methods)
        {
            if (func.name == name)
            {
                return func;
            }
        }

        if (!recurse)
            return null;

        if (!this.hasExtendTypes())
            return null;

        for(let extend of this.getCombineTypesList())
        {
            let mth = extend.getMethod(name, false);
            if(mth)
                return mth;
        }

        return null;
    }

    getMethodWithIdHint(name : string, idHint : number, recurse : boolean = true) : DBMethod | null
    {
        let fallback : DBMethod = null;
        for (let func of this.methods)
        {
            if (func.name == name)
            {
                if (func.id == idHint)
                    return func;
                else if (!fallback)
                    fallback = func;
            }
        }

        if (!recurse)
            return fallback;

        if (!this.hasExtendTypes())
            return fallback;

        for(let extend of this.getCombineTypesList())
        {
            let mth = extend.getMethodWithIdHint(name, idHint, false);
            if (mth)
            {
                if (mth.id == idHint)
                    return mth;
                else if (!fallback)
                    fallback = mth;
            }
        }

        return fallback;
    }

    inheritsFrom(checktype : string) : boolean
    {
        let it : DBType = this;
        let dbCheck : DBType = LookupType(this.namespace, checktype);
        if(!dbCheck)
            return false;
        let depth = 0;
        while(it && depth < 100)
        {
            if (it == dbCheck)
                return true;

            if (it.supertype)
            {
                it = LookupType(it.namespace, it.supertype);
                depth += 1;
                continue;
            }
            else if (it.unrealsuper)
            {
                it = LookupType(it.namespace, it.unrealsuper);
                depth += 1;
                continue;
            }
            else
            {
                break;
            }
        }
        return false;
    }

    isValueType() : boolean
    {
        if (this.isPrimitive)
            return true;
        if (this.isStruct)
            return true;
        if (this.isEnum)
            return true;
        return false;
    }

    getInheritanceTypes() : Array<DBType>
    {
        let typeList = new Array<DBType>();
        let check : DBType = this;
        while (check && typeList.indexOf(check) == -1)
        {
            typeList.push(check);
            check = LookupType(check.namespace, check.supertype);
        }
        return typeList;
    }

    canOverrideFromParent(methodname : string) : boolean
    {
        // Check script parents
        let checktype = this.supertype;
        let depth = 0;
        while (checktype && depth < 100)
        {
            let dbsuper = LookupType(this.namespace, checktype);
            if (!dbsuper)
                break;
            let method = dbsuper.getMethod(methodname, false);
            if (method)
            {
                if (!dbsuper.isUnrealType || method.isBlueprintEvent)
                    return true;
            }
            checktype = dbsuper.supertype;
            depth += 1;
        }

        return false;
    }

    hasOverriddenMethod(methodname : string) : boolean
    {
        for (let func of this.methods)
        {
            if (func.name == methodname)
                return true;
        }
        return false;
    }

    forEachSymbol(func : any)
    {
    }

    findFirstSymbol(name : string, allow_symbols = DBAllowSymbol.All) : DBSymbol | null
    {
        for (let type of this.getCombineTypesList())
        {
            let syms = type.symbols.get(name);
            if (syms instanceof Array)
            {
                for (let sym of syms)
                {
                    if (sym instanceof DBProperty)
                    {
                        if ((allow_symbols & DBAllowSymbol.Properties) == 0)
                            continue;
                        return sym;
                    }
                    else if (sym instanceof DBMethod)
                    {
                        if (sym.isMixin)
                        {
                            if ((allow_symbols & DBAllowSymbol.Mixins) == 0)
                                continue;
                        }
                        else
                        {
                            if ((allow_symbols & DBAllowSymbol.Functions) == 0)
                                continue;
                        }

                        return sym;
                    }
                }
            }
            else
            {
                return syms;
            }
        }

        return null;
    }

    // NOTE: Prefix must be at least 2 characters
    findFirstSymbolWithPrefix(prefix : string, allow_symbols = DBAllowSymbol.All, caseSensitive = true, depth = 100) : DBSymbol | null
    {
        if (prefix.length < 2)
            return null;

        let charPrefix = prefix.substring(0, 2).toLowerCase();
        for (let type of this.getCombineTypesList())
        {
            let syms = type.symbolsByPrefix.get(charPrefix);
            if (syms && syms.length != 0)
            {
                for (let sym of syms)
                {
                    if (sym instanceof DBProperty)
                    {
                        if ((allow_symbols & DBAllowSymbol.Properties) == 0)
                            continue;
                    }
                    else if (sym instanceof DBMethod)
                    {
                        if (sym.isMixin)
                        {
                            if ((allow_symbols & DBAllowSymbol.Mixins) == 0)
                                continue;
                        }
                        else
                        {
                            if ((allow_symbols & DBAllowSymbol.Functions) == 0)
                                continue;
                        }
                    }

                    if (caseSensitive)
                    {
                        if (sym.name.startsWith(prefix))
                            return sym;
                    }
                    else
                    {
                        if (sym.name.toLowerCase().startsWith(prefix.toLowerCase()))
                            return sym;
                    }
                }
            }
        }

        return null;
    }

    findSymbols(name : string) : Array<DBSymbol>
    {
        let result : Array<DBSymbol> = [];
        this.findSymbolsInternal(result, name);
        return result;
    }

    private findSymbolsInternal(result : Array<DBSymbol>, name : string)
    {
        for (let type of this.getCombineTypesList())
        {
            let syms = type.symbols.get(name);
            if (syms instanceof Array)
            {
                for (let sym of syms)
                    result.push(sym);
            }
            else
            {
                result.push(syms);
            }
        }
    }

    addSymbol(symbol : DBSymbol)
    {
        symbol.containingType = this;
        symbol.namespace = this.namespace;

        {
            let syms = this.symbols.get(symbol.name);
            if (!syms)
            {
                this.symbols.set(symbol.name, symbol);
            }
            else if (syms instanceof Array)
            {
                syms.push(symbol);
            }
            else
            {
                this.symbols.set(symbol.name, [symbol, syms]);
            }
        }

        if (symbol.name.length > 2)
        {
            let prefix = symbol.name.substr(0, 2).toLowerCase();
            let prefixSyms = this.symbolsByPrefix.get(prefix);
            if (!prefixSyms)
            {
                prefixSyms = new Array<DBSymbol>();
                this.symbolsByPrefix.set(prefix, prefixSyms);
            }

            prefixSyms.push(symbol);
        }
    }

    removeSymbol(symbol : DBSymbol)
    {
        {
            let syms = this.symbols.get(symbol.name);
            if (syms)
            {
                if (syms == symbol)
                {
                    this.symbols.delete(symbol.name);
                }
                else if (syms instanceof Array)
                {
                    let index = syms.indexOf(symbol);
                    if (index != -1)
                        syms.splice(index, 1);
                }
            }
        }

        if (symbol.name.length > 2)
        {
            let prefix = symbol.name.substr(0, 2).toLowerCase();
            let prefixSyms = this.symbolsByPrefix.get(prefix);
            if (prefixSyms)
            {
                let index = prefixSyms.indexOf(symbol);
                if (index != -1)
                    prefixSyms.splice(index, 1);
            }
        }
    }

    getTypeClassification() : DBTypeClassification
    {
        if (this.classification == DBTypeClassification.Unknown)
        {
            if (this.isDelegate)
                this.classification = DBTypeClassification.Delegate;
            else if (this.isEvent)
                this.classification = DBTypeClassification.Event;
            else if (this.isStruct)
                this.classification = DBTypeClassification.Struct;
            else if (this.isPrimitive)
                this.classification = DBTypeClassification.Primitive;
            else if (this.inheritsFrom("UActorComponent"))
                this.classification = DBTypeClassification.Component;
            else if (this.inheritsFrom("AActor"))
                this.classification = DBTypeClassification.Actor;
            else
                this.classification = DBTypeClassification.Other;
        }
        return this.classification;
    }

    getAccessSpecifier(name : string, create = true) : DBAccessSpecifier | null
    {
        if (this.acccessSpecifiers)
        {
            for (let spec of this.acccessSpecifiers)
            {
                if (spec.name == name)
                    return spec;
            }
        }

        if (create)
        {
            let spec = new DBAccessSpecifier();
            spec.name = name;
            spec.declaredType = this.name;

            if (this.acccessSpecifiers)
                this.acccessSpecifiers.push(spec);
            else
                this.acccessSpecifiers = [spec];

            return spec;
        }

        return null;
    }
};

export class DBNamespaceDeclaration
{
    declaredModule : string;
    declaredOffset : number;
    declaredOffsetEnd : number;
    scopeOffsetStart : number;
    scopeOffsetEnd : number;
}

export class DBNamespace
{
    name : string;
    documentation : string;

    parentNamespace : DBNamespace | null = null;

    childNamespaces = new Map<string, DBNamespace>();
    childNamespacesByPrefix = new Map<string, Array<DBNamespace>>();

    symbols = new Map<string, DBSymbol | Array<DBSymbol>>();
    symbolsByPrefix = new Map<string, Array<DBSymbol>>();

    declarations = new Array<DBNamespaceDeclaration>();

    // Get the full namespace starting at the root
    getQualifiedNamespace() : string
    {
        return "";
    }

    // Whether this namespace shadows a declared type
    isShadowingType() : boolean
    {
        if (!this.parentNamespace)
            return false;
        if (this.parentNamespace.findFirstSymbol(this.name, DBAllowSymbol.Types))
            return true;
        return false;
    }

    // Get which type this namespace is shadowing
    getShadowedType() : DBType | null
    {
        if (!this.parentNamespace)
            return null;
        let sym = this.parentNamespace.findFirstSymbol(this.name, DBAllowSymbol.Types);
        if (sym instanceof DBType)
            return sym;
        return null;
    }

    isRootNamespace() : boolean
    {
        return this.parentNamespace === null;
    }

    forEachSymbol(func : any)
    {
    }

    findFirstSymbol(name : string, allowSymbol : DBAllowSymbol = DBAllowSymbol.All) : DBSymbol | null
    {
        return null;
    }

    findFirstSymbolWithPrefix(prefix : string, caseSensitive = true, allowSymbol : DBAllowSymbol = DBAllowSymbol.All) : DBSymbol | null
    {
        return null;
    }

    findSymbols(name : string, allowSymbol : DBAllowSymbol = DBAllowSymbol.All) : Array<DBSymbol>
    {
        return null;
    }

    findSymbolsWithPrefix(prefix : string, caseSensitive = true, allowSymbol : DBAllowSymbol = DBAllowSymbol.All) : Array<DBSymbol>
    {
        return null;
    }

    findChildNamespace(name : string) : DBNamespace | null
    {
        return null;
    }

    findChildNamespacesWithPrefix(prefix : string, caseSensitive = true) : Array<DBNamespace>
    {
        return null;
    }

    addSymbol(symbol : DBSymbol)
    {
        symbol.containingType = null;
        symbol.namespace = this;

        {
            let syms = this.symbols.get(symbol.name);
            if (!syms)
            {
                this.symbols.set(symbol.name, symbol);
            }
            else if (syms instanceof Array)
            {
                syms.push(symbol);
            }
            else
            {
                this.symbols.set(symbol.name, [symbol, syms]);
            }
        }

        if (symbol.name.length > 2)
        {
            let prefix = symbol.name.substring(0, 2).toLowerCase();
            let prefixSyms = this.symbolsByPrefix.get(prefix);
            if (!prefixSyms)
            {
                prefixSyms = new Array<DBSymbol>();
                this.symbolsByPrefix.set(prefix, prefixSyms);
            }

            prefixSyms.push(symbol);
        }
    }

    removeSymbol(symbol : DBSymbol)
    {
        {
            let syms = this.symbols.get(symbol.name);
            if (syms)
            {
                if (syms == symbol)
                {
                    this.symbols.delete(symbol.name);
                }
                else if (syms instanceof Array)
                {
                    let index = syms.indexOf(symbol);
                    if (index != -1)
                        syms.splice(index, 1);
                }
            }
        }

        if (symbol.name.length > 2)
        {
            let prefix = symbol.name.substring(0, 2).toLowerCase();
            let prefixSyms = this.symbolsByPrefix.get(prefix);
            if (prefixSyms)
            {
                let index = prefixSyms.indexOf(symbol);
                if (index != -1)
                    prefixSyms.splice(index, 1);
            }
        }
    }

    addChildNamespace(childNS : DBNamespace)
    {
    }

    removeChildNamespace(childNS : DBNamespace)
    {
    }

    addScriptDeclaration(decl : DBNamespaceDeclaration)
    {
    }

    removeScriptDeclaration(moduleName : string)
    {
    }

    removeDeclaredSymbols(declaredModule : string)
    {
    }

    getDeclarationInModule(declaredModule : string) : DBNamespaceDeclaration | null
    {
        return null;
    }

    getFirstScriptDeclaration() : DBNamespaceDeclaration | null
    {
        return null;
    }

    getCppDeclaration() : DBNamespaceDeclaration | null
    {
        return null;
    }
};


export class DBAccessSpecifier
{
    name : string;
    declaredType : string;
    isDeclared : boolean = false;

    isPrivate : boolean = false;
    isProtected : boolean = false;

    bAnyReadOnly : boolean = false;
    bAnyEditDefaults : boolean = false;

    permissions : Array<DBAccessPermission>;

    declaredModule : string;
    moduleOffset : number;
    moduleOffsetEnd : number = -1;

    getAccess(fromType : DBType, fromFunction : DBMethod) : [boolean, boolean, boolean]
    {
        if (fromType == null && fromFunction == null)
            return [this.bAnyReadOnly, false, this.bAnyEditDefaults];

        if (fromType)
        {
            if (this.isProtected)
            {
                if (fromType.inheritsFrom(this.declaredType))
                    return [true, true, true];
            }
            else
            {
                if (fromType.name == this.declaredType)
                    return [true, true, true];
            }
        }

        let read = false;
        let write = false;
        let edit = false;

        if (this.bAnyEditDefaults)
            edit = true;
        if (this.bAnyReadOnly)
            read = true;

        if (this.permissions)
        {
            for (let cls of this.permissions)
            {
                let clsApplies = false;

                if (fromType)
                {
                    if (cls.bInherited)
                        clsApplies = fromType.inheritsFrom(cls.accessName);
                    else
                        clsApplies = (fromType.name == cls.accessName);
                }
                else if (fromFunction)
                {
                    clsApplies = (fromFunction.name == cls.accessName);
                }

                if (clsApplies)
                {
                    if (cls.bReadOnly)
                    {
                        read = true;

                        if (cls.bEditDefaults)
                            edit = true;
                    }
                    else
                    {
                        if (cls.bEditDefaults)
                        {
                            edit = true;
                        }
                        else
                        {
                            read = true;
                            edit = true;
                            write = true;
                        }
                    }
                }
            }
        }

        return [read, write, edit];
    }
};

export class DBAccessPermission
{
    accessName : string;
    bInherited : boolean = false;
    bReadOnly : boolean = false;
    bEditDefaults : boolean = false;
};

let DirtyTypeCacheId = 0;
export function OnDirtyTypeCaches()
{
    DirtyTypeCacheId++;
}

let UnrealTypesLoaded = false;
let RootNamespace = new DBNamespace;
let TypesById = new Map<number, DBType>();
let NamespacesByFullName = new Map<string, DBNamespace>();
let TypesByName = new Map<string, DBType | Array<DBType>>();

let NextMethodId = 1;
let NextTypeId = 1;

export function CleanTypeName(typename : string) : string
{
    if (typename.startsWith("const "))
        typename = typename.substring(6);
    if (typename.endsWith("&"))
        typename = typename.substring(0, typename.length-1);
    else if (typename.endsWith("&out"))
        typename = typename.substring(0, typename.length-4);
    else if (typename.endsWith("&in"))
        typename = typename.substring(0, typename.length-3);
    else if (typename.endsWith("&inout"))
        typename = typename.substring(0, typename.length-6);
    else if (typename.endsWith("@"))
        typename = typename.substring(0, typename.length-1);
    return typename;
}

export function TypenameEquals(left : string, right : string) : boolean
{
    return CleanTypeName(left) == CleanTypeName(right);
}

export function TransferTypeQualifiers(typename : string, newtype : string) : string
{
    if (typename.startsWith("const "))
        newtype = "const "+newtype;
    if (typename.endsWith("&"))
        newtype = newtype+"&";
    else if (typename.endsWith("&out"))
        newtype = newtype+"&out";
    else if (typename.endsWith("&in"))
        newtype = newtype+"&in";
    else if (typename.endsWith("&inout"))
        newtype = newtype+"&inout";
    return newtype;
}

let re_template = /([A-Za-z_0-9]+)\<(([A-Za-z_0-9]+\s*(<[A-Za-z_0-9,\s]+>)?,?)+)\>/;
export function ReplaceTemplateType(typename : string, templateTypes : Array<string>, actualTypes : Array<string>)
{
    typename = CleanTypeName(typename);
    for (let i = 0; i < templateTypes.length; ++i)
    {
        if (typename == templateTypes[i])
        {
            return actualTypes[i];
        }
    }

    if (typename.indexOf('<') != -1)
    {
        // Replace the template types inside the subtemplate as well
        let match = typename.match(re_template);
        if (match != null)
        {
            let basetype = match[1];

            let newtype = "";
            for (let subtype of match[2].split(","))
            {
                subtype = subtype.trim();
                let templIndex = templateTypes.indexOf(subtype);
                if (templIndex != -1)
                    subtype = actualTypes[templIndex];
                if (newtype.length != 0)
                    newtype += ",";
                newtype += subtype;
            }

            return basetype+"<"+newtype+">";
        }
    }

    return typename;
}

export function GetTypeByName(typename : string) : DBType | null
{
    let found = TypesByName.get(typename);
    if (found instanceof Array)
        return found[0];
    else
        return found;
}

export function GetTypeById(typeid : number) : DBType | null
{
    return TypesById.get(typeid);
}

export function GetAllTypesById() : Map<number, DBType>
{
    return TypesById;
}

export function GetAllNamespaces() : Map<string, DBNamespace>
{
    return NamespacesByFullName;
}

export function LookupNamespace(namespace : DBNamespace, name : string) : DBNamespace | null
{
    if (!namespace)
        namespace = RootNamespace;

    if (!name || name.length == 0)
        return namespace;

    // TODO: Split :: in namespace
    // TODO: Recursively search up in namespaces

    return namespace.findChildNamespace(name);
}

export function GetRootNamespace() : DBNamespace
{
    return RootNamespace;
}

export function DeclareNamespace(namespace : DBNamespace, name : string, decl : DBNamespaceDeclaration) : DBNamespace
{
    if (!namespace)
        namespace = RootNamespace;

    let ns = namespace.findChildNamespace(name);
    if (!ns)
    {
        ns = new DBNamespace();
        ns.name = name;
        ns.parentNamespace = RootNamespace;

        namespace.addChildNamespace(ns);
    }

    ns.addScriptDeclaration(decl);
    return ns;
}

export function RemoveNamespaceDeclaration(namespace : DBNamespace, moduleName : string)
{
    namespace.removeScriptDeclaration(moduleName);
    if (namespace.declarations.length == 0)
        namespace.parentNamespace.removeChildNamespace(namespace);
}

export function LookupType(namespace : DBNamespace, typename : string) : DBType | null
{
    if (!typename)
        return null;
    typename = CleanTypeName(typename);

    if (!namespace)
        namespace = RootNamespace;

    // TODO: Resolve :: in typename
    // TODO: Recursively search up in namespaces

    let foundType = namespace.findFirstSymbol(typename, DBAllowSymbol.Types);
    if (foundType instanceof DBType)
        return foundType;

    // See if we have to create a template instance
    if (typename.indexOf('<') != -1)
    {
        let match = typename.match(re_template);
        if (match != null)
        {
            let basetype = match[1];
            let subtypes = match[2].split(",").map(
                function(s : string) : string
                {
                    return s.trim();
                });

            let dbbasetype = LookupType(namespace, basetype);
            if (!dbbasetype)
                return null;

            let inst = dbbasetype.createTemplateInstance(subtypes);
            if (!inst)
                return null;
            inst.name = typename;
            if (!inst)
                return null;

            AddTypeToDatabase(namespace, inst);
            return inst;
        }
    }

    return null;
}

export function LookupGlobalSymbol(namespace : DBNamespace, name : string, allowSymbol = DBAllowSymbol.All) : Array<DBSymbol>
{
    if (!name)
        return [];

    if (!namespace)
        namespace = RootNamespace;

    // TODO: Resolve :: in typename
    // TODO: Recursively search up in namespaces

    let foundSymbols = namespace.findSymbols(name, allowSymbol);
    return foundSymbols;
}

export function LookupGlobalSymbolsWithPrefix(namespace : DBNamespace, prefix : string, allowSymbol = DBAllowSymbol.All) : Array<DBSymbol>
{
    if (!prefix)
        return [];

    if (!namespace)
        namespace = RootNamespace;

    // TODO: Resolve :: in typename
    // TODO: Recursively search up in namespaces

    return [];
}

export function HasTypeWithPrefix(namespace : DBNamespace, typenamePrefix : string, caseSensitive = true) : boolean
{
    if (!namespace)
        namespace = RootNamespace;

    // TODO: Resolve :: in typename
    // TODO: Recursively search up in namespaces

    let charPrefix = GetTypenameCharPrefix(typenamePrefix);
    if (!charPrefix)
        return true;

    let foundSym = namespace.findFirstSymbolWithPrefix(charPrefix, caseSensitive, DBAllowSymbol.Types);
    if (foundSym)
        return true;

    return false;
}

export function IsPrimitive(typename : string) : boolean
{
    let type = LookupType(null, typename);
    if (!type)
        return false;
    return type.isPrimitive;
}

function GetTypenameCharPrefix(typename : string) : string
{
    if (typename.length < 2)
        return null;
    return typename.substring(0, 2).toLowerCase();
}

let DatabaseFloatIsFloat64 = false;
let PrimitiveAliases = new Map<string, string>();

export function AddPrimitiveTypes(floatIsFloat64 : boolean)
{
    DatabaseFloatIsFloat64 = floatIsFloat64;

    PrimitiveAliases.clear();
    PrimitiveAliases.set("int", "int32");
    PrimitiveAliases.set("int32", "int32");
    PrimitiveAliases.set("int64", "int64");
    PrimitiveAliases.set("uint", "uint32");
    PrimitiveAliases.set("uint32", "uint32");
    PrimitiveAliases.set("uint64", "uint64");
    PrimitiveAliases.set("int8", "int8");
    PrimitiveAliases.set("uint8", "uint8");
    PrimitiveAliases.set("int16", "int16");
    PrimitiveAliases.set("uint16", "uint16");
    PrimitiveAliases.set("bool", "bool");

    if (DatabaseFloatIsFloat64)
        PrimitiveAliases.set("float", "float64");
    else
        PrimitiveAliases.set("float", "float32");

    PrimitiveAliases.set("float32", "float32");
    PrimitiveAliases.set("float64", "float64");
    PrimitiveAliases.set("double", "float64");

    for (let [primtype, alias] of PrimitiveAliases)
    {
        let dbtype = new DBType().initEmpty(primtype);
        dbtype.isPrimitive = true;
        AddTypeToDatabase(null, dbtype);
    }
}

export function ArePrimitiveTypesEquivalent(typenameA : string, typenameB : string) : boolean
{
    return (PrimitiveAliases.get(typenameA) == PrimitiveAliases.get(typenameB));
}

export function IsPrimitiveFloatType(typename : string) : boolean
{
    let realType = PrimitiveAliases.get(typename);
    return realType == "float32" || realType == "float64";
}

export function AddTypesFromUnreal(input : any)
{
    for (let key in input)
    {
        let type = new DBType();
        type.fromJSON(key, input[key]);

        if (type.name.startsWith("__"))
        {
            let ns = LookupNamespace(null, type.name.substring(2));
            if (!ns)
            {
                let decl = new DBNamespaceDeclaration();
                decl.declaredModule = null;
                ns = DeclareNamespace(null, type.name.substring(2), decl);
            }
            else
            {
                ns.removeDeclaredSymbols(null);
            }

            for (let [name, sym] of type.symbols)
            {
                if (sym instanceof Array)
                {
                    for (let symElem of sym)
                        ns.addSymbol(symElem);
                }
                else
                    ns.addSymbol(sym);
            }
        }
        else
        {
            AddTypeToDatabase(null, type);
        }
    }
}

export function HasTypesFromUnreal() : boolean
{
    return UnrealTypesLoaded;
}

export function FinishTypesFromUnreal()
{
    UnrealTypesLoaded = true;

    // Some hardcoded extra information we want to add to unreal functions
    let systemLib = RootNamespace.findChildNamespace("System");
    if (systemLib)
    {
        for (let functionName of [
            "SetTimer", "ClearTimer", "PauseTimer", "UnPauseTimer",
            "IsTimerActive", "IsTimerPaused", "TimerExists",
            "GetTimerElapsedTime", "GetTimerRemainingTime"
        ])
        {
            let timerFunc = systemLib.findFirstSymbol(functionName, DBAllowSymbol.Functions);
            if (timerFunc instanceof DBMethod)
            {
                timerFunc.isDelegateBindFunction = true;
                timerFunc.delegateBindType = "FTimerDynamicDelegate";
                timerFunc.delegateObjectParam = 0;
                timerFunc.delegateFunctionParam = 1;
            }
        }
    }

    // Annotate linear color creation functions
    let linearColorConstructors = RootNamespace.findSymbols("FLinearColor", DBAllowSymbol.Functions);
    for (let method of linearColorConstructors)
    {
        if (method instanceof DBMethod)
            method.methodAnnotation = DBMethodAnnotation.IsLinearColor;
    }

    let linearColorNS = RootNamespace.findChildNamespace("FLinearColor");
    if (linearColorNS)
    {
        let fromHexFunction = linearColorNS.findFirstSymbol("MakeFromHex", DBAllowSymbol.Functions);
        if (fromHexFunction instanceof DBMethod)
            fromHexFunction.methodAnnotation = DBMethodAnnotation.IsHexColor;
    }
}

export function AddTypeToDatabase(namespace : DBNamespace, dbtype : DBType)
{
    if (!namespace)
        namespace = RootNamespace;

    dbtype.namespace = namespace;
    dbtype.typeid = NextTypeId++;

    namespace.addSymbol(dbtype);
    TypesById.set(dbtype.typeid, dbtype);

    let found = TypesByName.get(dbtype.name);
    if (!found)
        TypesByName.set(dbtype.name, dbtype);
    else if (found instanceof Array)
        found.splice(0, 0, dbtype);
    else
        TypesByName.set(dbtype.name, [dbtype, found]);

    OnDirtyTypeCaches();
}

export function RemoveTypeFromDatabase(dbtype : DBType)
{
    if (!dbtype.namespace)
        return;

    dbtype.namespace.removeSymbol(dbtype);
    dbtype.namespace = null;

    TypesById.delete(dbtype.typeid);

    let found = TypesByName.get(dbtype.name);
    if (found == dbtype)
    {
        TypesByName.delete(dbtype.name);
    }
    else if (found instanceof Array)
    {
        let index = found.indexOf(dbtype);
        if (index != -1)
        {
            found.splice(index, 1);
            if (found.length == 1)
                TypesByName.set(dbtype.name, found[0]);
            else if (found.length == 0)
                TypesByName.delete(dbtype.name);
        }
    }

    OnDirtyTypeCaches();
}

let re_comment_star_start = /^[ \t]*\*+([ \t]|\r?\n)/gi;
let re_comment_star_end = /[\r\n]+[ \t]*\*+[ \t]*/gi;
export function FormatDocumentationComment(doc : string) : string
{
    doc = doc.replace(re_comment_star_end, "\n");
    doc = doc.replace(re_comment_star_start, " ");
    doc = doc.trim();
    return doc;
}